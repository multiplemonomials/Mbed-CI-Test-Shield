/*
 * Copyright (c) 2023 ARM Limited
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "mbed.h"
#include "greentea-client/test_env.h"
#include "unity.h"
#include "utest.h"

#include "ci_test_common.h"

using namespace utest::v1;

AnalogIn adc(PIN_ANALOG_IN);
PwmOut pwmOut(PIN_GPOUT_1);

// How long to wait when setting a PWM value for the hardware filter to settle
constexpr std::chrono::milliseconds PWM_FILTER_DELAY = 50ms; // nominal time constant 10ms

// GPIO output voltage expressed as a percent of the ADC reference voltage.  Experimentally determined by the first test case.
float ioVoltageADCPercent;

/*
 * Tests that we can see a response on the ADC when setting the PWM pin to a constant high or low value.
 */
void test_adc_digital_value()
{
    // Make sure turning the PWM off gets a zero volt input on the ADC
    pwmOut.write(0);
    ThisThread::sleep_for(PWM_FILTER_DELAY);
    float zeroVoltage = adc.read_voltage();
    TEST_ASSERT_FLOAT_WITHIN(.1f, 0, zeroVoltage);

    // Now see what happens when we turn the PWM all the way on
    pwmOut.write(1);
    ThisThread::sleep_for(PWM_FILTER_DELAY);
    ioVoltageADCPercent = adc.read();
    printf("With the PWM at full on, the ADC reads %.01f%% of reference voltage.\n", ioVoltageADCPercent * 100.0f);

    // We don't actually know what the IO voltage is relative to the ADC reference voltage, but it's a fair bet
    // that it should be at least 10%, so make sure we got at least some kind of reading
    TEST_ASSERT(ioVoltageADCPercent > 0.1f);

    // If the target provides an ADC Vref value, check that as well.
    if(isnan(MBED_CONF_TARGET_DEFAULT_ADC_VREF))
    {
        printf("Cannot convert to volts, target.default-adc-vref is not set for this target");
    }
    else
    {
        float ioVoltageVolts = adc.read_voltage();
        printf("Based on target.default-adc-vref of %.02fV, the digital IO voltage of this target is %.02fV.",
               MBED_CONF_TARGET_DEFAULT_ADC_VREF, ioVoltageVolts);

        // In a sane world we expect the IO voltage to be between 1.8 and 5 volts so we can at least check that
        // to help spot bad target.default-adc-vref values
        TEST_ASSERT(ioVoltageVolts >= 1.7f);
        TEST_ASSERT(ioVoltageVolts <= 5.1f);
    }

}

/*
 * Test reading analog values with the ADC.
 * The analog values are generated by sending a PWM signal through a hardware filter.
 */
void test_adc_analog_value()
{
    const size_t numSteps = 10;

    // Allow a 1% tolerance on the read ADC values.  That should be about right because most Mbed targets
    // have between an 8 bit and a 12 bit ADC.
    const float adcTolerancePercent = .01f;

    for(size_t stepIdx = 0; stepIdx < numSteps; ++stepIdx)
    {
        // Write the analog value
        float dutyCyclePercent = stepIdx / static_cast<float>(numSteps);
        pwmOut.write(dutyCyclePercent);
        ThisThread::sleep_for(PWM_FILTER_DELAY);

        // Get and check the result
        float adcPercent = adc.read();
        float expectedADCPercent = dutyCyclePercent * ioVoltageADCPercent;
        printf("PWM duty cycle of %.01f%% produced an ADC reading of %.01f%% (expected %.01f%%)\n",
               dutyCyclePercent * 100.0f, adcPercent * 100.0f, expectedADCPercent * 100.0f);
        TEST_ASSERT_FLOAT_WITHIN(adcTolerancePercent, expectedADCPercent, adcPercent);
    }
}

utest::v1::status_t test_setup(const size_t number_of_cases) {
    // Setup Greentea using a reasonable timeout in seconds
    GREENTEA_SETUP(30, "default_auto");

    // The filter in hardware is set up for a PWM signal of ~10kHz.
    pwmOut.period(.0001);

    return verbose_test_setup_handler(number_of_cases);
}

// Test cases
Case cases[] = {
        Case("Test reading digital values with the ADC", test_adc_digital_value),
        Case("Test reading analog values with the ADC", test_adc_analog_value),
};

Specification specification(test_setup, cases, greentea_continue_handlers);

// Entry point into the tests
int main()
{
    return !Harness::run(specification);
}
